--------------------------------------------------------------------
-- |
-- Module     : Grid
-- Copyright  : (c) Conor Reynolds 2016
-- License    : MIT
-- Maintainer : reynolds.conor@gmail.com
-- Stability  : experimental
-- Portability: non-portable
--
--------------------------------------------------------------------

{-# LANGUAGE RecordWildCards #-}

module Grid ( randomGrid
            , update

            -- Ships
            , rowOf10
            , lwss
            , gliderGun
            ) where

import Data.List (intersperse)
import Data.Word (Word8)
import System.Random (randomRIO)
import qualified Data.Vector.Unboxed as U

data Grid = Grid
  { rows :: {-# UNPACK #-} !Int
  , cols :: {-# UNPACK #-} !Int
  , vec  :: !(U.Vector Word8)
  }

-- | Performs a single board update
update :: Grid -> Grid
update g@(Grid _ _ v) = g { vec = U.zipWith updateCell v (neighbourCount g) }
  where
    updateCell 0 n = if n /= 3         then 0 else 1
    updateCell 1 n = if n `elem` [2,3] then 1 else 0
    updateCell _ _ = 0

-- | Generates a neighbour count for the current board. Using these update
--   rules, the grid (almost) forms a Euclidean 2-torus.
neighbourCount :: Grid -> U.Vector Word8
neighbourCount Grid{..} = for (U.enumFromN 0 (rows * cols)) $ \x ->
        vec ! (x - cols - 1) + vec ! (x - cols) + vec ! (x - cols + 1)
      + vec ! (x        - 1)                    + vec ! (x        + 1)
      + vec ! (x + cols - 1) + vec ! (x + cols) + vec ! (x + cols + 1)
  where
    for = flip U.map
    v ! n = v `U.unsafeIndex` (n `mod` U.length v)

-- | Generates a random grid with the given dimensions.
randomGrid :: Int -> Int -> IO Grid
randomGrid rs cs = Grid rs cs <$> U.replicateM (rs * cs) (randomRIO (0, 1))

-----------------
--   Drawing   --
-----------------

parseAsciiGrid :: String -> Grid
parseAsciiGrid s =
  let numRows = length $        lines s
      numCols = length $ head $ lines s
  in Grid {
      rows = numRows
    , cols = numCols
    , vec  = U.fromList $ map (\x -> if x == '.' then 0 else 1)
                        $ filter (/= '\n') s
  }

-- | 10 cell row
rowOf10 = parseAsciiGrid
  "................................................\n\
  \................................................\n\
  \................................................\n\
  \................................................\n\
  \................................................\n\
  \................................................\n\
  \...................##########...................\n\
  \................................................\n\
  \................................................\n\
  \................................................\n\
  \................................................\n\
  \................................................\n\
  \................................................\n"

-- | Lightweight space ship
lwss = parseAsciiGrid
  "..........................................................\n\
  \..........................................................\n\
  \..........................................................\n\
  \..........................................................\n\
  \.......#..#...............................................\n\
  \...........#..............................................\n\
  \.......#...#..............................................\n\
  \........####..............................................\n\
  \..........................................................\n\
  \..........................................................\n\
  \..........................................................\n\
  \..........................................................\n\
  \..........................................................\n\
  \..........................................................\n\
  \..........................................................\n"

-- | Gosper's Glider Gun (with eater)
gliderGun = parseAsciiGrid
  "........................................................................\n\
  \........................................................................\n\
  \........................................................................\n\
  \........................................................................\n\
  \........................................................................\n\
  \........................................................................\n\
  \..........................................#.............................\n\
  \........................................#.#.............................\n\
  \..............................##......##............##..................\n\
  \.............................#...#....##............##..................\n\
  \..................##........#.....#...##................................\n\
  \..................##........#...#.##....#.#.............................\n\
  \............................#.....#.......#.............................\n\
  \.............................#...#......................................\n\
  \..............................##........................................\n\
  \........................................................................\n\
  \........................................................................\n\
  \........................................................................\n\
  \........................................................................\n\
  \........................................................................\n\
  \........................................................................\n\
  \........................................................................\n\
  \........................................................................\n\
  \........................................................................\n\
  \........................................................................\n\
  \........................................................................\n\
  \........................................................................\n\
  \........................................................................\n\
  \........................................................................\n\
  \........................................................................\n\
  \........................................................##..............\n\
  \........................................................#.#.............\n\
  \..........................................................#.............\n\
  \..........................................................##............\n\
  \........................................................................\n"

-- | Return of the Horrible Show Instance™
instance Show Grid where
  show Grid{..} = "╭" ++ replicate (2*cols + 1) '─' ++ "╮" ++ "\n"
               ++ groupRows (U.map (\x -> if x == 0 then ' ' else '▣') vec)
               ++ "╰" ++ replicate (2*cols + 1) '─' ++ "╯"
    where
      groupRows :: U.Vector Char -> String
      groupRows v
        | U.null v  = ""
        | otherwise = "│ " ++ intersperse ' ' (U.toList (U.take cols v)) ++ " │\n"
                           ++ groupRows (U.drop cols v)
